### **ゼビウス風ブラウザSTG 詳細設計書**

ご提示の要件定義を基に、各要素をブレークダウンし、実装に必要なパラメータ、ロジック、データ構造を具体化しました。

#### **1. 基本仕様要件【詳細】**

##### **1.1. 操作体系**
* **キーボード操作:**
    * 移動: `ArrowUp`, `ArrowDown`, `ArrowLeft`, `ArrowRight`。斜め移動を許可。
    * ザッパー (対空攻撃): `Z` キー。キープレス中に連射。
    * ブラスター (対地攻撃): `X` キー。キープレスで照準表示。キーリリースで投下。
* **タッチ操作:**
    * **移動:** 画面の任意の場所をタッチしてドラッグ。自機はタッチした指の位置に追従する。
    * **ザッパー:** 自動連射。自機の移動中、常に一定間隔で発射される。
    * **ブラスター:**
        * 画面下部の特定UIエリア（例: 画面横幅の20%領域）をタップすると、その位置の真上（ゲームフィールド上）にブラスターを投下する。
        * または、2本指目のタップでブラスターを投下する。この場合、1本目の指で移動、2本目の指のタップ位置を照準としてブラスターを投下する。

##### **1.2. 攻撃システム**
* **対空攻撃「ザッパー」:**
    * **弾速:** 1フレームあたり `15` ピクセル。
    * **連射間隔:** `10` フレーム（60fps環境で秒間6発）。
    * **同時発射数:** 画面内に最大 `3` 発まで。`3` 発発射済みの場合は、いずれかの弾が画面外に出るか敵に命中するまで次の弾は発射不可。
    * **弾のグラフィック:** 長方形のシンプルな形状。
* **対地攻撃「ブラスター」:**
    * **照準:**
        * 自機の前方、固定距離（例: `100` ピクセル先）に常に表示。
        * 自機の左右移動に合わせて、照準も左右にスライドする。
        * 地上ターゲットと重複した場合、`2` フレーム毎に赤と白で点滅。
    * **投下と着弾:**
        * 投下から着弾までの時間: `30` フレーム。
        * 着弾時に爆風エフェクトを `15` フレーム表示。
    * **複数同時破壊:**
        * 爆風の当たり判定（円形）に入った地上物を全て破壊対象とする。
        * 爆風の半径は `32` ピクセル。最大 `4` つのターゲットを同時に破壊可能。

#### **2. コアゲーム要素【詳細】**

##### **2.1. 敵キャラクター**
* **敵データ構造 (JSON形式の例):**
    ```json
    {
      "id": "toroid",
      "type": "air", // "air" or "ground"
      "hp": 1,
      "score": 50,
      "sprite": "path/to/toroid.png",
      "behaviorPattern": "straight_down",
      "attackPattern": "none"
    }
    ```
* **空中敵 (代表例):**
    * **トーロイド:** 画面上部から直進。攻撃なし。最も基本的な敵。
    * **ザカート:** 画面上部から出現し、サインカーブを描きながら下降。弾は撃たない。
    * **バキュラ:** 高耐久力の板状の敵。破壊不能。弾も撃たない。プレイヤーの障害物となる。
    * **ゾシー:** 特定位置で停止し、自機に向かって単発の弾を発射後、画面外へ離脱。
* **地上敵 (代表例):**
    * **デロータ (回転砲台):** 常に回転しており、特定の間隔で4方向に弾を発射。
    * **ドム・グラム (地上基地):** 非武装だが、破壊時のスコアが高い。
    * **グロブダー (戦車):** 一定のルートを移動し、自機が一定範囲内に入ると停止して単発の弾を発射。
* **出現パターン:**
    * ステージのスクロール距離（ピクセル単位）をキーとして、どの敵がどの座標に出現するかを定義したタイムライン形式のJSONで管理する。
    * **例:**
        ```json
        "stageTimeline": [
          { "scrollPos": 1000, "enemyId": "toroid", "spawnX": 240 },
          { "scrollPos": 1200, "enemyId": "zakato", "spawnX": 100 },
          ...
        ]
        ```

##### **2.2. ステージ構成**
* **スクロール速度:** 一定速度（例: 1フレームあたり `3` ピクセル）。
* **エリア:**
    * 1エリア長 = `(画面の高さ) * 7.1` ピクセル。
    * エリアの終端にはボスキャラクター「アンドアジェネシス」が出現。
    * アンドアジェネシスを破壊すると次のエリアへ進む。
* **背景:**
    * 地上マップは1枚の巨大な画像として用意。スクロールに合わせて描画範囲をずらしていく。
    * 雲などを別レイヤーで異なる速度でスクロールさせることで、擬似的な多重スクロールを表現する。

##### **2.3. スコアシステム**
* **スコアテーブル:**
    * 空中敵: `50` ～ `200` 点
    * 地上敵: `200` ～ `2000` 点
    * アンドアジェネシス（コア）: `10000` 点
* **残機追加 (エクステンド):**
    * スコアが `20,000` 点に達するごとに残機が `1` 増加。その後は `80,000` 点ごとに増加。
    * 残機が増えた際は、効果音と共に画面に「1UP」と表示する。

##### **2.4. 隠し要素**
* **「ソル」:**
    * 特定の地上物（`3` つのピラミッド状のオブジェクト）を、ブラスターで特定の順番（例: 左→右→中）で破壊すると出現。
    * 出現後は、画面内を `8` の字を描くように飛行する。
    * 自機が接触すると取得。取得時に `2000` 点のボーナス。効果音と共に画面が白くフラッシュする。

#### **3. クラス設計案**

より具体的なプログラムの構造として、以下のクラス設計を提案します。

* **`GameManager` (シングルトン):**
    * プロパティ: `score`, `highScore`, `playerLives`, `gameState` (`playing`, `gameOver`, `paused`)
    * メソッド: `startGame()`, `gameOver()`, `addScore()`, `extendPlayer()`
* **`Player`:**
    * プロパティ: `position`, `speed`, `state` (`normal`, `invincible`), `invincibleTimer`
    * メソッド: `update()`, `move(direction)`, `shootZapper()`, `dropBlaster()`, `onHit()`
* **`BlasterSight`:**
    * プロパティ: `position`, `isTargeting`
    * メソッド: `update(playerPosition)`, `checkTarget(groundEnemies)`
* **`Enemy` (基底クラス):**
    * プロパティ: `id`, `type`, `position`, `hp`, `score`
    * メソッド: `update()`, `onHit()`, `destroy()`
* **`AirEnemy`, `GroundEnemy` (Enemyを継承):**
    * それぞれ固有の移動パターンや攻撃ロジックを実装。
* **`Bullet` (基底クラス):**
    * プロパティ: `position`, `velocity`
    * メソッド: `update()`
* **`ZapperBullet`, `BlasterBomb` (Bulletを継承):**
    * それぞれ固有の挙動を実装。
* **`CollisionManager`:**
    * メソッド: `checkPlayerVsEnemy()`, `checkZapperVsEnemy()`, `checkBlasterVsEnemy()`
    * 判定ロジック:
        * 基本は**矩形判定**で高速に処理。
        * 自機と敵弾など、より精密な判定が求められる箇所は**円形判定**を検討。
* **`ObjectPoolManager`:**
    * 弾や頻繁に出現する敵を事前に生成・保持し、再利用することでGC（ガベージコレクション）の負荷を軽減する。
    * メソッド: `getObject(type)`, `returnObject(object)`
* **`InputManager`:**
    * キーボードとタッチの入力を抽象化し、`Player`クラスに `move`, `shoot` といった単純な命令を伝える。
* **`EffectManager`:**
    * 爆発、ヒットエフェクト、スコア表示などの描画を管理する。

#### **4. ゲームシーケンス**

1.  **タイトル画面:**
    * ゲームタイトル表示。
    * ハイスコア表示。
    * 「GAME START」ボタン（またはキー入力）。
2.  **ゲーム本編:**
    * `GameManager`がゲームループを開始。
    * `Player`、`Enemy`、`Bullet`等のオブジェクトを更新・描画。
    * スクロール処理、当たり判定、スコア加算を実行。
    * 自機の被弾時:
        * 爆発エフェクト再生。残機を-1。
        * `3` 秒間の無敵時間と共に自機が再出現。
    * 残機が`0`の状態で被弾するとゲームオーバーへ。
3.  **ゲームオーバー画面:**
    * 「GAME OVER」表示。
    * 最終スコア表示。
    * タイトル画面へ戻るボタン。
4.  **ポーズ機能:**
    * `P`キーまたは画面上のポーズボタンでゲームループを一時停止/再開。

#### **5. 非機能要件【詳細】**

* **セーブ機能:**
    * **ハイスコア:** `localStorage.setItem('xevious_highscore', score)` の形式で保存。
    * **リプレイデータ:**
        * ゲーム開始時の乱数シードと、フレーム毎のプレイヤーの入力情報（`{frame: 1, input: 'right'}`のような形式）を配列として記録。
        * ゲームオーバー時にこの配列をJSON化し、`Base64`にエンコードしてクリップボードにコピーできる機能を提供する。他者はこの文字列をデコードしてリプレイを再生できる。
* **デバッグ要件:**
    * **デバッグパネル:**
        * 画面の隅にデバッグ情報を表示/非表示できる。
        * 表示項目: FPS, オブジェクト数, 自機座標, 無敵モードON/OFF。
    * **デバッグ用キーコマンド:**
        * `I`: 自機無敵モードの切り替え。
        * `K`: 周囲の敵を全滅させる。
        * `N`: 次のエリアへスキップする。
    * **敵出現パターンエディタ:**
        * Webベースの別ツールとして開発。
        * ゲーム画面と同じ背景上で、時間軸（スクロール位置）に沿って敵アイコンをドラッグ＆ドロップで配置し、JSONとしてエクスポートできる機能。

#### 利用する画像
- 利用する画像は、テスト用に準備をしてください。著作権を留意してダミー画像・キャラを準備してください。